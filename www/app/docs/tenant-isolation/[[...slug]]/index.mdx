# Tenant Isolation

export const meta = {
  order: 3,
};

All SaaS applications provide service to multiple customers or tenants. Isolating each tenant's data from another tenant is so basic yet hard to do. Nile enables tenant data isolation without any complex, buggy code or dealing with messy row-level security policies. With Postgres being tenant-aware in Nile, this becomes straightforward. 

## What is tenant data isolation?

A SaaS application serves many tenants. The data for each tenant belongs to the tenant and should not be accessible to other tenants. The users who belong to a specific tenant can access the data they have access to for that tenant. This seems so obvious but yet so hard to achieve in practice. 

In Nile, you can think about it as a single Postgres that has many virtual tenant DBs. You can control where these virtual DBs should be placed. This can be on multitenant or dedicated instances. You get to decide while creating the tenant. This can also be in any region of the world. Nile enables isolation with a single line of code in your application. Nile also ensures user authorization is enforced within a tenant if you use our user management (more about this later)
![Tenant Isolation](/docs/tenant-isolation.png)

## Enforcing tenant data isolation
Nile makes it really easy to enforce tenant data isolation. Let us take a recruiting SaaS product that helps a company to source, interview and hire candidates for different jobs open to be filled. A simplified version will have a ‘candidates’ table that tracks all the candidates in flight. The list of candidate is private to each company using the recruiting product. Given that the candidate information needs to be private to each company, let us create a tenant aware table in Nile’s Postgres.

```sql
create table candidates (
  tenant_id uuid,
  id integer,
  name text,
  status text,
  resume_url text,
  job_applied text,
  applied_date TIMESTAMP,
  CONSTRAINT FK_tenants FOREIGN KEY(tenant_id) REFERENCES tenants(id),
  CONSTRAINT PK_candidates PRIMARY KEY(tenant_id,id));
```

```sql
insert into tenants (name) values ('customer1'),('customer2'),('customer3'),('customer4'),('customer5')
```

Let us populate the candidate table for couple of tenants. Typically, these candidates will be inserted by the application as candidates apply for the job. We will manually populate them in this case.

```sql
-- inserting candidates for tenant 018ade1a-7830-7981-b23f-f3a7f7b8f09f
insert into candidates
  (tenant_id,id,name,status, resume_url, job_applied, applied_date)
values
  (018ade1a-7830-7981-b23f-f3a7f7b8f09f,1324,'Candidate1','New Application','http://myresume.com/index.html','software engineer','2023-08-22 19:10:25-07'),
  (018ade1a-7830-7981-b23f-f3a7f7b8f09f,2356,'Candidate2','Phone Interview','http://myprofile.com/index.html','senior software engineer','2023-07-12 18:09:15-07');
-- inserting candidates for tenant 018ade1a-7843-7e60-9686-714bab650998
insert into candidates
  (tenant_id,id,name,status, resume_url, job_applied, applied_date)
values
  ('018ade1a-7843-7e60-9686-714bab650998',2532,'Candidate1','Onsite','http://checkresume.com/index.html','Principal engineer','2023-07-20 12:08:14-06'),
  ('018ade1a-7843-7e60-9686-714bab650998',7374,'Candidate2','Final round','http://forinterview.com/index.html','Product manager','2023-06-04 11:08:11-06'),
  ('018ade1a-7843-7e60-9686-714bab650998',8345,'Candidate3','Recruiter screen','http://career.com/index.html','Saled engineer','2023-09-10 10:08:12-06');
```

Now we have a table of candidates for multiple customers populated.

```sql
select * from candidates;
```
<table>
  <thead>
    <tr>
      <th>tenant_id</th>
      <th>id</th>
      <th>name</th>
      <th>status</th>
      <th>resume_url</th>
      <th>job_applied</th>
      <th>applied_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>018ade1a-7830-7981-b23f-f3a7f7b8f09f</td>
      <td>1324</td>
      <td>Candidate 1</td>
      <td>New Application</td>
      <td>http://myresume.com/index.html</td>
      <td>software engineer</td>
      <td>2023-08-22T19:10:25.000</td>
    </tr>
    <tr>
      <td>018ade1a-7830-7981-b23f-f3a7f7b8f09f</td>
      <td>2356</td>
      <td>Candidate 2</td>
      <td>Phone Interview</td>
      <td>http://myprofile.com/index.html</td>
      <td>senior software engineer</td>
      <td>2023-07-12T18:09:15.000Z</td>
    </tr>
    <tr>
      <td>018ade1a-7843-7e60-9686-714bab650998</td>
      <td>2532</td>
      <td>Candidate 1</td>
      <td>Onsite</td>
      <td>http://checkresume.com/index.html</td>
      <td>Principal engineer</td>
      <td>2023-07-20T12:08:14.000Z</td>
    </tr>
    <tr>
      <td>018ade1a-7843-7e60-9686-714bab650998</td>
      <td>7374</td>
      <td>Candidate 2</td>
      <td>Final round</td>
      <td>http://forinterview.com/index.html</td>
      <td>Product manager</td>
      <td>2023-06-04T11:08:11.000Z</td>
    </tr>
    <tr>
      <td>018ade1a-7843-7e60-9686-714bab650998</td>
      <td>8345</td>
      <td>Candidate 3</td>
      <td>Recruiter screen</td>
      <td>http://career.com/index.html</td>
      <td>Sales engineer</td>
      <td>2023-09-10T10:08:12.000Z</td>
    </tr>
  </tbody>
</table>

In a typical SaaS application, you would want to access the data of a specific tenant when user accesses the application. You also want to make sure the data from another tenant is not seen. This is typically hard without implementing complex permissions at the application level or enforcing row level security policies in Postgres which is hard to maintain, debug and error prone. 

Nile has first class support for tenant isolation at for SQL and all our SDKs which makes it very trivial to do. At the SQL layer, setting a session context to a specific tenant is equivalent to pointing the connection to a specific tenant DB. You can still access shared tables in this mode but the other virtual tenant DBs are not accessible. We also provide a very simple user context mode which adds additional security on top of the tenant context. Read more about this in user authorization.

<CodeGroups>
    ```sql
-- set session context to the tenant you want to access.
set nile.tenant_id = '018ade1a-7830-7981-b23f-f3a7f7b8f09f';
select * from candidates;
```
 ```typescript
import ApiClient from '@example/protocol-api'
const client = new ApiClient(token)
await client.conversations.list()
    ```
</CodeGroups>

<table>
  <thead>
    <tr>
      <th>tenant_id</th>
      <th>id</th>
      <th>name</th>
      <th>status</th>
      <th>resume_url</th>
      <th>job_applied</th>
      <th>applied_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>018ade1a-7830-7981-b23f-f3a7f7b8f09f</td>
      <td>1324</td>
      <td>Candidate 1</td>
      <td>New Application</td>
      <td>http://myresume.com/index.html</td>
      <td>software engineer</td>
      <td>2023-08-22T19:10:25.000</td>
    </tr>
    <tr>
      <td>018ade1a-7830-7981-b23f-f3a7f7b8f09f</td>
      <td>2356</td>
      <td>Candidate 2</td>
      <td>Phone Interview</td>
      <td>http://myprofile.com/index.html</td>
      <td>senior software engineer</td>
      <td>2023-07-12T18:09:15.000Z</td>
    </tr>
  </tbody>
</table>
## Querying across tenants


## What is tenant performance isolation?

## How does Nile achieve performance isolation between tenants?